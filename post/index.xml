<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on My Hugo Site</title>
    <link>https://WSG114514.github.io/post/</link>
    <description>Recent content in Posts on My Hugo Site</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Sun, 26 Jan 2020 12:40:04 +0800</lastBuildDate>
    
	<atom:link href="https://WSG114514.github.io/post/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>切比雪夫距离算法-路径最优选择</title>
      <link>https://WSG114514.github.io/post/chebyshev/</link>
      <pubDate>Sun, 26 Jan 2020 12:40:04 +0800</pubDate>
      
      <guid>https://WSG114514.github.io/post/chebyshev/</guid>
      <description>国际象棋棋盘上二个位置间的切比雪夫距离是指王要从一个位子移至另一个位子需要走的步数。由于王可以往斜前或斜后方向移动一格，因此可以较有效率的到达目的的格子。数学上，切比雪夫距离或是L∞度量，是向量空间中的一种度量，二个点之间的距离定义为其各座标数值差绝对值的最大值。比较常用的实例就是在无障碍的情况下计算两点之间的路程，沿水平或者竖直方向移动一个单位长度，或者跨过对角线的时间相同。
例题：平面上有 n 个点，点的位置用整数坐标表示 points[i] = [xi, yi]。请你计算访问所有这些点需要的最小时间（以秒为单位）。
你可以按照下面的规则在平面上移动：
每一秒沿水平或者竖直方向移动一个单位长度，或者跨过对角线（可以看作在一秒内向水平和竖直方向各移动一个单位长度）。 必须按照数组中出现的顺序来访问这些点。
示例 1： 输入：points = [[1,1],[3,4],[-1,0]] 输出：7 解释：一条最佳的访问路径是： [1,1] -&amp;gt; [2,2] -&amp;gt; [3,3] -&amp;gt; [3,4] -&amp;gt; [2,3] -&amp;gt; [1,2] -&amp;gt; [0,1] -&amp;gt; [-1,0]
从 [1,1] 到 [3,4] 需要 3 秒 从 [3,4] 到 [-1,0] 需要 4 秒 一共需要 7 个单位时间。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/minimum-time-visiting-all-points
解决代码：
class Solution {public int minTimeToVisitAllPoints(int[][] points) {int res=0;for(int i=1;i&amp;lt;points.length;i++) {int wid=Math.abs(points[i][0]-points[i-1][0]);//算出两点之间横坐标的距离winint hei=Math.abs(points[i][1]-points[i-1][1]);//算出两点之间从坐标的距离heiif(wid==hei) {res+=wid;}else {int min=Math.</description>
    </item>
    
    <item>
      <title>数据结构-自定义链表队列（Java泛型）</title>
      <link>https://WSG114514.github.io/post/linkedlistqueue/</link>
      <pubDate>Thu, 23 Jan 2020 21:48:14 +0800</pubDate>
      
      <guid>https://WSG114514.github.io/post/linkedlistqueue/</guid>
      <description>用链表实现的队列，用head指向开头，用tail指向最后一个元素，所以在head指向的对象执行出队，在tail指向的对象执行入队。在本篇结束时附带，数组数组队列，循环队列，链表队列的算法比较。方法解释在之前的Queue接口设置中已经说明。
public class LinkedListQueue&amp;lt;E&amp;gt; implements Queue&amp;lt;E&amp;gt; {private class Node{public E e;public Node next;public Node(E e,Node next) {this.e=e;this.next=next;}public Node(E e) {this(e, null);}public Node() {this(null,null);}@Overridepublic String toString() {return e.toString();}} 成员变量
private Node head,tail;private int size; 构造函数
public LinkedListQueue() {head=null;tail=null;size=0;}@Overridepublic int getSize() {return size;}@Overridepublic boolean isEmpty() {return size==0;} 入队方法，在队列为空时head=tail。</description>
    </item>
    
    <item>
      <title>数据结构-自定义动态链表（Java泛型）</title>
      <link>https://WSG114514.github.io/post/linkedlist/</link>
      <pubDate>Thu, 23 Jan 2020 21:35:38 +0800</pubDate>
      
      <guid>https://WSG114514.github.io/post/linkedlist/</guid>
      <description>自定义一个真正意义上的动态数据结构LinkedList，链表。在文章最后附带利用本次实现的链表作为底层实现的链表栈。
public class LinkedList&amp;lt;E&amp;gt; { 内部类Node用来存储数据，Node型的next指向下一个元素
private class Node{public E e;public Node next;public Node(E e,Node next) {this.e=e;this.next=next;} public Node(E e) {this(e, null);}public Node() {this(null,null);}@Overridepublic String toString() {return e.toString();}}	private Node dummyhead;//设置虚拟头节点private int size;public LinkedList() {dummyhead=new Node(null,null);size=0;} 获取链表中的元素个数
public int getSize() {return size;} 返回链表受否为空
public boolean siEmpty() {return size==0;} 在链表的index位置添加新的元素e,复杂度O(n) 在链表中并不是一个常用的操作，练习用:)</description>
    </item>
    
    <item>
      <title>数据结构-自定义循环队列（Java泛型）</title>
      <link>https://WSG114514.github.io/post/loopqueue/</link>
      <pubDate>Sun, 19 Jan 2020 19:57:14 +0800</pubDate>
      
      <guid>https://WSG114514.github.io/post/loopqueue/</guid>
      <description>自定义的一个动态循环队列，与数组队列有所不同，新加入两个变量，front为栈首位置，tail为加入元素位置，当队列为空的时候front=tail，当（tail+1）%c=front时队列满，在队列的Capacipy中，总要浪费一个空间。在本章的后面有循环队列与数组队列的比较。（由于在循环队列中添加一个元素的方法复杂度变为O（1），相比数组队列的添加算法复杂度O（n）要快很多）
接口定义
public interface Queue&amp;lt;E&amp;gt; {int getSize();//获取队列长度boolean isEmpty();//判断队列是否为空void enqueue(E e);//向队尾添加E dequeue();//获取队首的元素E getFront();//查看队首的元素} 自定义循环队列
public class LoopQueue&amp;lt;E&amp;gt;implements Queue&amp;lt;E&amp;gt; { 成员变量
private E[] data;private int front,tail;//front为栈首，tail为加入元素对象private int size;//元素个数 构造函数
public LoopQueue(int capacity) {data=(E[])new Object[capacity+1];front=0;tail=0;size=0;}public LoopQueue() {this(10);} 基本方法
public int getCapacity() {return data.length-1;}@Overridepublic int getSize() {return size;}@Overridepublic boolean isEmpty() {return front==tail;}@Overridepublic void enqueue(E e) {//复杂度O(1)if((tail+1)%data.</description>
    </item>
    
    <item>
      <title>数据结构-自定义数组队列（Java泛型）</title>
      <link>https://WSG114514.github.io/post/arrayqueue/</link>
      <pubDate>Sun, 19 Jan 2020 19:45:41 +0800</pubDate>
      
      <guid>https://WSG114514.github.io/post/arrayqueue/</guid>
      <description>自定义的一个动态数组队列，类似于Array篇中Array类的子类，存储结构如同字面上的意思，先进先出。
接口定义
public interface Queue&amp;lt;E&amp;gt; {int getSize();//获取队列长度boolean isEmpty();//判断队列是否为空void enqueue(E e);//向队尾添加E dequeue();//获取队首的元素E getFront();//查看队首的元素} 自定义数组队列
public class ArrayQueue&amp;lt;E&amp;gt; implements Queue&amp;lt;E&amp;gt;{ 成员变量
private Array&amp;lt;E&amp;gt; array; 构造方法
public ArrayQueue(int capacity) {array=new Array&amp;lt;&amp;gt;(capacity);}public ArrayQueue() {array=new Array&amp;lt;&amp;gt;();} 基本方法
@Overridepublic int getSize() {//复杂度O(1)return array.getSize();}@Overridepublic boolean isEmpty() {return array.isEmpty();}@Overridepublic void enqueue(E e) {//复杂度O(1)array.addlist(e);}@Overridepublic E dequeue() {//复杂度O(n)return array.</description>
    </item>
    
    <item>
      <title>数据结构-自定义动态栈（Java泛型）</title>
      <link>https://WSG114514.github.io/post/stack/</link>
      <pubDate>Sat, 18 Jan 2020 22:18:42 +0800</pubDate>
      
      <guid>https://WSG114514.github.io/post/stack/</guid>
      <description>自定义的一个动态栈，方法很简单，所用到的方法基本在我的上一篇Array类中已经实现了，栈结构虽然简单但是非常重要，按照其先进后出的存储模式运用在撤销操作中很实用，在本页面最后附带LeetCode第20道题解法，（给定一个只包括 &amp;lsquo;(&#39;，&#39;)&#39;，&#39;{&#39;，&#39;}&#39;，&#39;[&#39;，&#39;]&amp;rsquo; 的字符串，判断字符串是否有效。）此题为twitter等许多大公司面试经典实用例题。
接口定义
public interface Stack&amp;lt;E&amp;gt; {int getSize();//获取栈长度boolean isEmpty();//判断栈是否为空void push(E e);//向栈中加入元素E pop();//取出栈顶元素E peek();//查看栈顶元素 自定义动态栈
public class ArrayStack&amp;lt;E&amp;gt; implements Stack&amp;lt;E&amp;gt; {Array&amp;lt;E&amp;gt; array;//成员变量（在自定义Array类中写的动态数组）//构造函数public ArrayStack(int capacity) {array=new Array&amp;lt;&amp;gt;(capacity);}public ArrayStack() {array=new Array&amp;lt;&amp;gt;(10);}@Override//时间复杂度O（1）public int getSize() {return array.getSize();}@Override//时间复杂度O（1）public boolean isEmpty() {return array.isEmpty();}@Override//时间复杂度O（1）public void push(E e) {array.addlist(e);}@Override//时间复杂度O（1）public E pop() {return array.</description>
    </item>
    
    <item>
      <title>数据结构-自定义动态数组（Java泛型）</title>
      <link>https://WSG114514.github.io/post/blog/</link>
      <pubDate>Wed, 15 Jan 2020 00:17:52 +0800</pubDate>
      
      <guid>https://WSG114514.github.io/post/blog/</guid>
      <description>自定义类Array，实现动态存储数据，实现基本增删改查功能，优化内存存储。
public class Array&amp;lt;E&amp;gt; {private E[] data;private int size; 有参构造函数
public Array(int capacity) {data =(E[])new Object[capacity];size=0;} 无参构造函数
public Array() {this(10);}public int getSize() {return size;}public int getCapacity() {return data.length;}public boolean isEmpty() {return size==0;} 在末尾加入一个元素
public void addlist(E e) {add(size, e);} 在开头加入一个元素
public void addFirst(E e) {add(0,e);} 在数组指定位置加入一个数组</description>
    </item>
    
  </channel>
</rss>