<!doctype html>
<html lang="en-us">
  <head>
    <title>数据结构-自定义循环队列（Java泛型） // My Hugo Site</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.62.2" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Jon" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://wsg114514.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="数据结构-自定义循环队列（Java泛型）"/>
<meta name="twitter:description" content="自定义的一个动态循环队列，与数组队列有所不同，新加入两个变量，front为栈首位置，tail为加入元素位置，当队列为空的时候front=tail，当（tail&#43;1）%c=front时队列满，在队列的Capacipy中，总要浪费一个空间。在本章的后面有循环队列与数组队列的比较。（由于在循环队列中添加一个元素的方法复杂度变为O（1），相比数组队列的添加算法复杂度O（n）要快很多）
接口定义
public interface Queue&lt;E&gt; {int getSize();//获取队列长度boolean isEmpty();//判断队列是否为空void enqueue(E e);//向队尾添加E dequeue();//获取队首的元素E getFront();//查看队首的元素} 自定义循环队列
public class LoopQueue&lt;E&gt;implements Queue&lt;E&gt; { 成员变量
private E[] data;private int front,tail;//front为栈首，tail为加入元素对象private int size;//元素个数 构造函数
public LoopQueue(int capacity) {data=(E[])new Object[capacity&#43;1];front=0;tail=0;size=0;}public LoopQueue() {this(10);} 基本方法
public int getCapacity() {return data.length-1;}@Overridepublic int getSize() {return size;}@Overridepublic boolean isEmpty() {return front==tail;}@Overridepublic void enqueue(E e) {//复杂度O(1)if((tail&#43;1)%data."/>

    <meta property="og:title" content="数据结构-自定义循环队列（Java泛型）" />
<meta property="og:description" content="自定义的一个动态循环队列，与数组队列有所不同，新加入两个变量，front为栈首位置，tail为加入元素位置，当队列为空的时候front=tail，当（tail&#43;1）%c=front时队列满，在队列的Capacipy中，总要浪费一个空间。在本章的后面有循环队列与数组队列的比较。（由于在循环队列中添加一个元素的方法复杂度变为O（1），相比数组队列的添加算法复杂度O（n）要快很多）
接口定义
public interface Queue&lt;E&gt; {int getSize();//获取队列长度boolean isEmpty();//判断队列是否为空void enqueue(E e);//向队尾添加E dequeue();//获取队首的元素E getFront();//查看队首的元素} 自定义循环队列
public class LoopQueue&lt;E&gt;implements Queue&lt;E&gt; { 成员变量
private E[] data;private int front,tail;//front为栈首，tail为加入元素对象private int size;//元素个数 构造函数
public LoopQueue(int capacity) {data=(E[])new Object[capacity&#43;1];front=0;tail=0;size=0;}public LoopQueue() {this(10);} 基本方法
public int getCapacity() {return data.length-1;}@Overridepublic int getSize() {return size;}@Overridepublic boolean isEmpty() {return front==tail;}@Overridepublic void enqueue(E e) {//复杂度O(1)if((tail&#43;1)%data." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wsg114514.github.io/post/loopqueue/" />
<meta property="article:published_time" content="2020-01-19T19:57:14+08:00" />
<meta property="article:modified_time" content="2020-01-19T19:57:14+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://wsg114514.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="Jon" /></a>
      <h1>My Hugo Site</h1>
      <p>Hello visitor , nice to meet you~~~</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/WSG114514" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">数据结构-自定义循环队列（Java泛型）</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Jan 19, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div></div>
    </header>
    <div class="post-content">
      <p>自定义的一个动态循环队列，与数组队列有所不同，新加入两个变量，front为栈首位置，tail为加入元素位置，当队列为空的时候front=tail，当（tail+1）%c=front时队列满，在队列的Capacipy中，总要浪费一个空间。在本章的后面有循环队列与数组队列的比较。（由于在循环队列中添加一个元素的方法复杂度变为O（1），相比数组队列的添加算法复杂度O（n）要快很多）</p>
<p>接口定义</p>
<pre><code>public interface Queue&lt;E&gt; {
    int getSize();//获取队列长度
    boolean isEmpty();//判断队列是否为空
    void enqueue(E e);//向队尾添加
    E dequeue();//获取队首的元素
    E getFront();//查看队首的元素
}
</code></pre>
<p>自定义循环队列</p>
<pre><code>public class LoopQueue&lt;E&gt;implements Queue&lt;E&gt; {
</code></pre>
<p>成员变量</p>
<pre><code>private E[] data;
private int front,tail;//front为栈首，tail为加入元素对象
private int size;//元素个数
</code></pre>
<p>构造函数</p>
<pre><code>public LoopQueue(int capacity) {
    data=(E[])new Object[capacity+1];
    front=0;
    tail=0;
    size=0;
}
public LoopQueue() {
    this(10);
}
</code></pre>
<p>基本方法</p>
<pre><code>public int getCapacity() {
    return data.length-1;
}
@Override
public int getSize() {
    return size;
}
@Override
public boolean isEmpty() {
    return front==tail;
}
@Override
public void enqueue(E e) {//复杂度O(1)
    if((tail+1)%data.length== front)
        resize(getCapacity()*2);
    data[tail]=e;
    tail=(tail+1)%data.length;//注意不是tail++;
    size++;
}
public void resize(int newCapacity) {//复杂度O(1)
    E[] newdata=(E[])new Object[newCapacity+1];
    for(int i=0;i&lt;size;i++) {
        newdata[i]=data[(front+i)%data.length];
    }
    data=newdata;
    front=0;
    tail=size;
}
@Override
public E dequeue() {//复杂度O(1)
    if(isEmpty())
        throw new IllegalArgumentException(&quot;Cannot dequeue from an empty queue.&quot;);
	
    E ret=data[front];
    data[front]=null;
    front=(front+1)%data.length;//注意不是front++
    size--;
    if(size==getCapacity()/4&amp;&amp;getCapacity()/2!=0)
        resize(getCapacity()/2);
    return ret;
}
@Override
public E getFront() {//复杂度O(1)
    if(isEmpty())
        throw new IllegalArgumentException(&quot;Queue is empty.&quot;);
    return data[front];
}
@Override
public String toString() {
    StringBuilder res=new StringBuilder();
    res.append(String.format(&quot;Queue:size=%d,capacity=%d\n&quot;, size,getCapacity()));
    res.append(&quot;front [&quot;);
    for(int i=front;i!=tail;i=(i+1)%data.length) {
        res.append(data[i]);
        if((i+1)%data.length!=tail)
            res.append(&quot;,&quot;);
    }
    res.append(&quot;] tail&quot;);
    return res.toString();
}
}
</code></pre>
<p>添加一个实例，比较循环队列与数组队列的运算速度。
运算方法</p>
<pre><code>    private static double testQueue(Queue&lt;Integer&gt;queue,int opCount) {
    long startTime=System.nanoTime();
    Random random=new Random();
    for(int i=0;i&lt;opCount;i++) {
        queue.enqueue(random.nextInt(Integer.MAX_VALUE));
    }
    for(int i=0;i&lt;opCount;i++) {
        queue.dequeue();
    }
    long endTime=System.nanoTime();
    return (endTime-startTime)/1000000000.0;
}

public static void main(String[] args) {
    int opCount=100000;
    ArrayQueue&lt;Integer&gt; arrayQueue=new ArrayQueue&lt;Integer&gt;();
    double time1=testQueue(arrayQueue, opCount);
    System.out.println(&quot;ArrayQueue,time:&quot;+time1+&quot;s&quot;);
    LoopQueue&lt;Integer&gt; loopQueue=new LoopQueue&lt;Integer&gt;();
    double time2=testQueue(loopQueue, opCount);
    System.out.println(&quot;ArrayQueue,time:&quot;+time2+&quot;s&quot;);
    }
    运算结果：
    ArrayQueue,time:3.5933936s
    ArrayQueue,time:0.0133714s</code></pre>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
