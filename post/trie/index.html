<!doctype html>
<html lang="en-us">
  <head>
    <title>数据结构-字典树（Java） // My Hugo Site</title>
    <meta charset="utf-8" />
    <meta name="generator" content="Hugo 0.62.2" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <meta name="author" content="Jon" />
    <meta name="description" content="" />
    <link rel="stylesheet" href="https://wsg114514.github.io/css/main.min.f90f5edd436ec7b74ad05479a05705770306911f721193e7845948fb07fe1335.css" />

    
    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="数据结构-字典树（Java）"/>
<meta name="twitter:description" content="线段树用来存储单词，以每一个字母为一个节点，利用TreeMap映射关系字母key指向下一个节点。
import java.util.TreeMap;//需要用到映射
字典树,存储character对象
public class Trie {private class Node{ 到这个字母时判断是否已经是一个单词
 public boolean isWord;public TreeMap&lt;Character, Node&gt; next; 内部类构造函数
 public Node(boolean isWord) {this.isWord=isWord;next=new TreeMap&lt;Character, Trie.Node&gt;();}public Node() {this(false);}}private Node root;//根节点private int size;//存储单词数量 构造函数
public Trie() {root=new Node();size=0;} 获得Trie中存储的单词数量
public int getSize() {return size;} 添加一个单词word，把单词拆成一个个字母，把字母放进Trie树里。
public void add(String word) {Node cur=root;for(int i=0;i&lt;word."/>

    <meta property="og:title" content="数据结构-字典树（Java）" />
<meta property="og:description" content="线段树用来存储单词，以每一个字母为一个节点，利用TreeMap映射关系字母key指向下一个节点。
import java.util.TreeMap;//需要用到映射
字典树,存储character对象
public class Trie {private class Node{ 到这个字母时判断是否已经是一个单词
 public boolean isWord;public TreeMap&lt;Character, Node&gt; next; 内部类构造函数
 public Node(boolean isWord) {this.isWord=isWord;next=new TreeMap&lt;Character, Trie.Node&gt;();}public Node() {this(false);}}private Node root;//根节点private int size;//存储单词数量 构造函数
public Trie() {root=new Node();size=0;} 获得Trie中存储的单词数量
public int getSize() {return size;} 添加一个单词word，把单词拆成一个个字母，把字母放进Trie树里。
public void add(String word) {Node cur=root;for(int i=0;i&lt;word." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://wsg114514.github.io/post/trie/" />
<meta property="article:published_time" content="2020-02-15T09:31:21+08:00" />
<meta property="article:modified_time" content="2020-02-15T09:31:21+08:00" />


  </head>
  <body>
    <header class="app-header">
      <a href="https://wsg114514.github.io"><img class="app-header-avatar" src="/avatar.jpg" alt="Jon" /></a>
      <h1>My Hugo Site</h1>
      <p>Hello visitor , nice to meet you~~~</p>
      <div class="app-header-social">
        
          <a target="_blank" href="https://github.com/WSG114514" rel="noreferrer noopener"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-github">
  <title>github</title>
  <path d="M9 19c-5 1.5-5-2.5-7-3m14 6v-3.87a3.37 3.37 0 0 0-.94-2.61c3.14-.35 6.44-1.54 6.44-7A5.44 5.44 0 0 0 20 4.77 5.07 5.07 0 0 0 19.91 1S18.73.65 16 2.48a13.38 13.38 0 0 0-7 0C6.27.65 5.09 1 5.09 1A5.07 5.07 0 0 0 5 4.77a5.44 5.44 0 0 0-1.5 3.78c0 5.42 3.3 6.61 6.44 7A3.37 3.37 0 0 0 9 18.13V22"></path>
</svg></a>
        
      </div>
    </header>
    <main class="app-container">
      
  <article class="post">
    <header class="post-header">
      <h1 class ="post-title">数据结构-字典树（Java）</h1>
      <div class="post-meta">
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-calendar">
  <title>calendar</title>
  <rect x="3" y="4" width="18" height="18" rx="2" ry="2"></rect><line x1="16" y1="2" x2="16" y2="6"></line><line x1="8" y1="2" x2="8" y2="6"></line><line x1="3" y1="10" x2="21" y2="10"></line>
</svg>
          Feb 15, 2020
        </div>
        <div>
          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-clock">
  <title>clock</title>
  <circle cx="12" cy="12" r="10"></circle><polyline points="12 6 12 12 16 14"></polyline>
</svg>
          2 min read
        </div></div>
    </header>
    <div class="post-content">
      <p>线段树用来存储单词，以每一个字母为一个节点，利用TreeMap映射关系字母key指向下一个节点。</p>
<p>import java.util.TreeMap;//需要用到映射</p>
<p>字典树,存储character对象</p>
<pre><code>public class Trie {
    private class Node{
</code></pre>
<p>到这个字母时判断是否已经是一个单词</p>
<pre><code>    public boolean isWord;
    public TreeMap&lt;Character, Node&gt; next;
</code></pre>
<p>内部类构造函数</p>
<pre><code>    public Node(boolean isWord) {
        this.isWord=isWord;
        next=new TreeMap&lt;Character, Trie.Node&gt;();
    }
    public Node() {
        this(false);
    }
}
private Node root;//根节点
private int  size;//存储单词数量
</code></pre>
<p>构造函数</p>
<pre><code>public Trie() {
    root=new Node();
    size=0;
}
</code></pre>
<p>获得Trie中存储的单词数量</p>
<pre><code>public int getSize() {
    return size;
}
</code></pre>
<p>添加一个单词word，把单词拆成一个个字母，把字母放进Trie树里。</p>
<pre><code>public void add(String word) {
    Node cur=root;
    for(int i=0;i&lt;word.length();i++) {
        char c=word.charAt(i);
</code></pre>
<p>——————————————————————重点——————————————————————把做成节点</p>
<pre><code>        //当next的Node为空时说明这个字母c到下一个next的路径为空
        if(cur.next.get(c)==null) {
            //创建路径
            cur.next.put(c, new Node());
        }
        cur=cur.next.get(c);
    }
    //此时已经指到单词最后一个字母
    if(!cur.isWord) {
        cur.isWord=true;
        size++;
    }
}
//查询单词word是否在Trie中
public boolean contains(String word) {
    Node cur=root;
    for(int i=0;i&lt;word.length();i++) {
        char c=word.charAt(i);
        if(cur.next.get(c)==null) {
            return false;
        }
        cur=cur.next.get(c);
    }
    return cur.isWord;
}
</code></pre>
<p>查询是否在Trie中是否有单词以prefix为前缀</p>
<pre><code>public boolean isPrefix(String prefix){
    Node cur=root;
    for(int i=0;i&lt;prefix.length();i++) {
        char c=prefix.charAt(i);
        if(cur.next.get(c)==null) {
            return false;
        }
        cur=cur.next.get(c);
    }
    return true;
}
private boolean match(Node node,String word,int index){
    if(index==word.length()){
        return node.isWord;
    }
    char c=word.charAt(index);
    if(c!='.'){
        if(node.next.get(c)==null){
            return false;
        }
        return match(node.next.get(c),word,index+1);
    }else{
        for(char nextChar:node.next.keySet()){
            if(match(node.next.get(nextChar),word,index+1)){
                return true;
            }
        }
        return false;
    }
}
}
</code></pre>
<p>性能比较：</p>
<pre><code>public static void main(String[] args) {
	
    System.out.println(&quot;Pride and Prejudice&quot;);
    ArrayList&lt;String&gt; words=new ArrayList&lt;String&gt;();
    if(FileOperation.readFile(&quot;pride-and-prejudice.txt&quot;, words)) {
        long startTime1=System.nanoTime();
        BSTSet&lt;String&gt; set=new BSTSet&lt;String&gt;();
        for(String word:words)
            set.add(word);
        for(String word:words)
            set.contains(word);
        long endTime1=System.nanoTime();
        double time1=(endTime1-startTime1)/1000000000.0;
        System.out.println(&quot;Total different words:&quot;+set.getSize()+&quot;  set:&quot;+time1);
		
        long startTime2=System.nanoTime();
        Trie trie=new Trie();
        for(String word:words)
            trie.add(word);
        for(String word:words)
            trie.contains(word);
        long endTime2=System.nanoTime();
        double time2=(endTime2-startTime2)/1000000000.0;
        System.out.println(&quot;Total different words:&quot;+trie.getSize()+&quot;  trie:&quot;+time2);
    }
}
</code></pre>
<p>结果：（由于单词量少反而set更占优势，只有在单词量巨大时Trie的优势才能体现）</p>
<pre><code>Pride and Prejudice
Total different words:4109  set:0.0383061
Total different words:4109  trie:0.0909797</code></pre>

    </div>
    <div class="post-footer">
      
    </div>
  </article>

    </main>
  </body>
</html>
